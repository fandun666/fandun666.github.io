---
title: Android Developers 应用架构
date: 2024-07-10 19:54:38
tags: [Android]
categories: [Android Developers]
---
典型的**Android**应用包含多个应用组件，包括**Activity**、**Fragment**、**Service**、**ContentProvider**和**BroadcastReceiver**。您需要在应用清单中声明其中的大多数应用组件。**Android**操作系统随后会使用此文件来决定如何将您的应用集成到设备的整体用户体验中。鉴于典型的**Android**应用可能包含多个组件，并且用户经常会在短时间内与多个应用进行互动，因此应用需要适应不同类型的用户驱动型工作流和任务。

请注意，移动设备的资源也很有限，因此操作系统可能随时终止某些应用进程以便为新的进程腾出空间。

鉴于这种环境条件，您的应用组件可以不按顺序地单独启动，并且操作系统或用户可以随时销毁它们。由于这些事件不受您的控制，因此您不应在内存中存储或保留任何应用数据或状态，并且应用组件不应相互依赖。

# 简介
## 常见的架构原则
如果您不应使用应用组件存储应用数据和状态，那么您应该改为如何设计应用呢？

随着**Android**应用大小不断增加，您定义的架构务必要能允许应用扩缩、提升应用的稳健性并且方便对应用进行测试。

应用架构定义了应用的各个部分之间的界限以及每个部分应承担的职责。为了满足上述需求，您应该按照某些特定原则设计应用架构。
### 分离关注点
要遵循的最重要的原则是分离关注点。 一种常见的错误是在一个**Activity**或**Fragment**中编写所有代码。这些基于界面的类应仅包含处理界面和操作系统交互的逻辑。您应使这些类尽可能保持精简，这样可以避免许多与组件生命周期相关的问题，并提高这些类的可测试性。

请注意，您并非拥有**Activity**和**Fragment**的实现；它们只是表示**Android**操作系统与应用之间关系的粘合类。操作系统可能会根据用户互动或因内存不足等系统条件随时销毁它们。为了提供令人满意的用户体验和更易于管理的应用维护体验，最好尽量减少对它们的依赖。
### 通过数据模型驱动界面
另一个重要原则是您应该通过数据模型驱动界面（最好是持久性模型）。数据模型代表应用的数据。它们独立于应用中的界面元素和其他组件。这意味着它们与界面和应用组件的生命周期没有关联，但仍会在操作系统决定从内存中移除应用的进程时被销毁。

持久性模型是理想之选，原因如下：
- 如果**Android**操作系统销毁应用以释放资源，用户不会丢失数据。
- 当网络连接不稳定或不可用时，应用会继续工作。

如果您的应用架构以数据模型类为基础，您的应用会更便于测试、更稳定可靠。
### 单一数据源
在应用中定义新数据类型时，您应为其分配单一数据源 (**SSOT**)。**SSOT**是该数据的所有者，而且只有此**SSOT**可以修改或转变该数据。为了实现这一点，**SSOT**会以不可变类型公开数据；而且为了修改数据，**SSOT**会公开函数或接收其他类型可以调用的事件。

此模式具有多种优势：
- 将对特定类型数据的所有更改集中到一处。
- 保护数据，防止其他类型篡改此数据。
- 更易于跟踪对数据的更改。因此，也就更容易发现 bug。

在离线优先应用中，应用数据的单一数据源通常是数据库。在其他某些情况下，单一数据源可以是**ViewModel**甚至是界面。
### 单向数据流
在我们的指南中，单一数据源原则常常与单向数据流 (**UDF**) 模式一起使用。在**UDF**中，状态仅朝一个方向流动。修改数据的事件朝相反方向流动。

在**Android**中，状态或数据通常从分区层次结构中较高的分区类型流向较低的分区类型。事件通常在分区层次结构中较低的分区类型触发，直到其到达**SSOT**的相应数据类型。例如，应用数据通常从数据源流向界面。用户事件（例如按钮按下操作）从界面流向**SSOT**，在**SSOT**中应用数据被修改并以不可变类型公开。

此模式可以更好地保证数据一致性，不易出错、更易于调试，并且具备**SSOT**模式的所有优势。
## 推荐的应用架构
>本页中提供的建议和最佳实践可应用于各种应用。遵循这些建议和最佳实践可以提升应用的可扩展性、质量和稳健性，并可使应用更易于测试。不过，您应该将这些提示视为指南，并视需要进行调整来满足您的要求。

基于上一部分提到的常见架构原则，每个应用应至少有两个层：
- 界面层 - 在屏幕上显示应用数据。
- 数据层 - 包含应用的业务逻辑并公开应用数据。

您可以额外添加一个名为“网域层”的架构层，以简化和重复使用界面层与数据层之间的交互。

![典型应用架构的示意图](https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-overview.png?hl=zh-cn)

>注意：本指南示意图中的箭头表示各个类之间的依赖关系。例如，网域层依赖于数据层类。

### 现代应用架构
此现代应用架构鼓励采用以下方法及其他一些方法：
- 反应式分层架构。
- 应用的所有层中的单向数据流 (UDF)。
- 包含状态容器的界面层，用于管理界面的复杂性。
- 协程和数据流。
- 依赖项注入最佳实践。

### 界面层
界面层（或呈现层）的作用是在屏幕上显示应用数据。每当数据发生变化时，无论是因为用户互动（例如按了某个按钮），还是因为外部输入（例如网络响应），界面都应随之更新，以反映这些变化。
界面层由以下两部分组成：
- 在屏幕上呈现数据的界面元素。您可以使用**View**或**Jetpack Compose**函数构建这些元素。
- 用于存储数据、向界面提供数据以及处理逻辑的状态容器（如**ViewModel**类）。

![界面层在应用架构中的作用](https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-overview-ui.png?hl=zh-cn)

### 数据层
应用的数据层包含业务逻辑。业务逻辑决定应用的价值，它包含决定应用如何创建、存储和更改数据的规则。

数据层由多个仓库组成，其中每个仓库都可以包含零到多个数据源。您应该为应用中处理的每种不同类型的数据分别创建一个存储库类。例如，您可以为与电影相关的数据创建一个**MoviesRepository**类，或者为与付款相关的数据创建一个**PaymentsRepository**类。

![数据层在应用架构中的作用](https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-overview-data.png?hl=zh-cn)

存储库类负责以下任务：
- 向应用的其余部分公开数据。
- 集中处理数据变化。
- 解决多个数据源之间的冲突。
- 对应用其余部分的数据源进行抽象化处理。
- 包含业务逻辑。

每个数据源类应仅负责处理一个数据源，数据源可以是文件、网络来源或本地数据库。数据源类是应用与数据操作系统之间的桥梁。
### 网域层
网域层是位于界面与数据层之间的可选层。

网域层负责封装复杂的业务逻辑，或者由多个**ViewModel**重复使用的简单业务逻辑。此层是可选的，因为并非所有应用都有这类需求。请仅在需要时使用该层，例如处理复杂逻辑或支持可重用性。

![网域层在应用架构中的作用](https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-overview-domain.png?hl=zh-cn)

此层中的类通常称为“用例”或“交互方”。每个用例都应仅负责单个功能。例如，如果多个**ViewModel**依赖时区在屏幕上显示适当的消息，则您的应用可能具有**GetTimeZoneUseCase**类。
## 管理组件之间的依赖关系
应用中的类要依赖其他类才能正常工作。您可以使用以下任一设计模式来收集特定类的依赖项：
- 依赖注入 (DI)：依赖注入使类能够定义其依赖项而不构造它们。在运行时，另一个类负责提供这些依赖项。
- 服务定位器：服务定位器模式提供了一个注册表，类可以从中获取其依赖项而不构造它们。

您可以借助这些模式来扩展代码，因为它们可提供清晰的依赖项管理模式（无需复制代码，也不会增添复杂性）。 此外，您还可以借助这些模式在测试和生产实现之间快速切换。

我们建议在**Android**应用中采用依赖项注入模式并使用**Hilt**库。**Hilt**通过遍历依赖项树自动构造对象，为依赖项提供编译时保证，并为**Android**框架类创建依赖项容器。
## 常见的最佳实践
编程是一个创造性的领域，构建**Android**应用也不例外。 无论是在多个**activity**或**fragment**之间传递数据，检索远程数据并将其保留在本地以在离线模式下使用，还是复杂应用遇到的任何其他常见情况，解决问题的方法都会有很多种。

虽然以下建议不是强制性的，但在大多数情况下，遵循这些建议会使您的代码库更强大、可测试性更高且更易维护：

#### 不要将数据存储在应用组件中。

请避免将应用的入口点（如**Activity**、**Service**和**BroadcastReceiver**）指定为数据源。相反，您应只将其与其他组件协调，以检索与该入口点相关的数据子集。每个应用组件存在的时间都很短暂，具体取决于用户与其设备的交互情况以及系统当前的整体运行状况。

#### 减少对 Android 类的依赖。

您的应用组件应该是唯一依赖于**Android**框架SDK API（例如**Context**或**Toast**）的类。将应用中的其他类与这些类分离开来有助于改善可测试性，并减少应用中的耦合。

#### 在应用的各个模块之间设定明确定义的职责界限。

例如，请勿在代码库中将从网络加载数据的代码散布到多个类或软件包中。同样，也不要将不相关的职责（如数据缓存和数据绑定）定义到同一个类中。遵循推荐的应用架构可以帮助您解决此问题。

#### 尽量少公开每个模块中的代码。

例如，请勿试图创建从模块提供内部实现细节的快捷方式。短期内，您可能会省点时间，但随着代码库的不断发展，您可能会反复陷入技术上的麻烦。

#### 专注于应用的独特核心，以使其从其他应用中脱颖而出。

不要一次又一次地编写相同的样板代码，这是在做无用功。 相反，您应将时间和精力集中放在能让应用与众不同的方面上，并让**Jetpack**库以及建议的其他库处理重复的样板。

#### 考虑如何使应用的每个部分可独立测试。

例如，如果使用明确定义的 API 从网络获取数据，将会更容易测试在本地数据库中保留该数据的模块。如果您将这两个模块的逻辑混放在一处，或将网络代码分散在整个代码库中，那么即便能够进行有效测试，难度也会大很多。

#### 类型负责其并发政策。

如果某种类型正在执行长时间运行的阻塞工作，则应负责将该计算移至正确的线程。该特定类型知道它正在执行的计算类型及其应在哪个线程中执行。类型应该具有主线程安全性，这意味着，您可以安全地从主线程调用这些类型而不会阻塞。

#### 保留尽可能多的相关数据和最新数据。

这样，即使用户的设备处于离线模式，他们也可以使用您应用的功能。请记住，并非所有用户都能享受到稳定的高速连接 - 即使有时可以使用，在比较拥挤的地方网络信号也可能不佳。
## 架构的优势
在应用中实现良好的架构会为项目和工程团队带来诸多好处：
- 提高整个应用的可维护性、质量和稳健性。
- 允许应用扩缩。尽可能减少代码冲突，使更多人和更多团队可以为同一代码库做贡献。
- 有助于新手上手。架构能使您的项目保持一致性，让团队中的新成员可以快速上手，并在更短时间内提高效率。
- 更易于测试。良好的架构鼓励使用更简单的类型，这些类型通常更易于测试。
- 可以使用明确定义的流程有条理地调查 bug。
在架构方面的投入也会对您的用户产生直接积极影响。用户能从更稳定的应用中获益；同时，由于工程团队效率提高，用户还可以享受更多功能。但是，架构也需要前期时间投入。请阅读这些案例研究，了解其他公司在应用中使用良好架构的成功案例，这有助于您向公司其他人员证明时间的合理性。

# 模块化
## 代码库不断变大的问题
在不断变大的代码库中，可扩缩性、可读性和整体代码质量通常会随着时间的推移而降低。这是因为代码库在不断变大，而其维护者未采取积极措施来保持易于维护的结构。模块化是一种行之有效的代码库构建方法，可帮助改善可维护性并避免此类问题。
## 什么是模块化？
模块化是按多个松散耦合的独立部分整理代码库的做法。每个部分都是一个模块。每个模块都是独立的，并且都有明确的用途。通过将问题划分为更小、更易于解决的子问题，您可以降低设计和维护大型系统的复杂性。

![多模块代码库示例的依赖关系图](https://developer.android.google.cn/static/topic/modularization/images/1_sample_dep_graph.png?hl=zh-cn)

## 模块化的优势
模块化具有众多优势，但核心都是提高代码库的可维护性和整体质量。下表总结了模块化的主要优势。

|  优势   | 摘要  |
|  ----  | ----  |
| 可重用性  | 模块化可支持在同一基础上共享代码并构建多个应用。模块实际上就是构建块。应用应为其各项功能的总和，而这些功能按单独的模块进行划分。特定模块提供的功能不一定会在特定的应用中实现。例如，**:feature:news**可以是完整版本变种和**Wear**应用的一部分，但不是演示版本变种的一部分。 |
| 严格控制可见性  | 借助模块，您可以轻松控制向代码库的其他部分公开哪些内容。您可以将除公共接口以外的所有内容标记为**internal**或**private**，以防止在模块外部使用这些内容。 |
| 自定义分发  | [Play Feature Delivery](https://developer.android.google.cn/guide/playcore/feature-delivery?hl=zh-cn) 使用了**app bundle**的多种高级功能，让您可以按条件或按需分发应用的某些功能。 |

上述优势只能通过模块化代码库实现。采用其他方法也可实现以下优势，但模块化可以帮助您进一步强化这些优势。

|  优势   | 总结  |
|  ----  | ----  |
| 可伸缩性  | 在紧密耦合的代码库中，单项更改可能会触发看似不相关的代码部分的级联更改。适当模块化的项目将遵循关注点分离原则，因此可限制耦合。这样一来，贡献者将拥有更大的自主权。 |
| 所有权  | 除了实现自主权外，模块还可用于实现问责制原则。可以由一个专门的所有者来负责为模块维护代码、修复 bug、添加测试以及查看更改。 |
| 封装  | 封装意味着代码的每个部分都应尽可能少地了解其他部分。隔离的代码更易于阅读和理解。 |
| 可测试性  | 可测试性是指测试代码的轻松程度。可测试代码是指可以轻松单独测试组件的代码。 |
| 构建时间  | 某些**Gradle**功能（如增量构建、构建缓存或并行构建）可以利用模块化来提升构建性能。 |

## 常见误区
代码库的粒度是指其模块化程度。更细粒度的代码库包含更多、更小的模块。在设计模块化代码库时，您应当决定粒度级别。为此，请考虑代码库的大小及其相对复杂度。过于精细化的设计会增加开销负担，而过于粗略又会降低模块化的优势。

下面列出了一些常见误区：
- **过于精细**：每个模块都会产生一定的开销，包括增加构建复杂度以及引入样板代码。复杂的 build 配置会导致难以在模块之间保持配置一致。过多的样板代码会导致代码库冗长累赘，难以维护。如果开销抵消了可伸缩性方面的改进，则应考虑整合某些模块。
- **过于粗略**：相反，如果模块过大，最终可能会产生另一个单体式模块，失去模块化的优势。例如，在小项目中，将数据层放到单一模块中是没有问题的。但随着模块变大，您可能需要将代码库和数据源拆分为独立的模块。
- **过于复杂**：构建模块化项目并非总是明智的做法。代码库的大小是一项决定因素。如果您预计项目不会变大到超过某个特定阈值，则不必考虑可伸缩性和构建时间。

## 高内聚和低耦合原则
表征模块化代码库的一种方式是使用耦合和内聚属性。耦合用于衡量模块相互依赖的程度。在本指南中，内聚用于衡量单个模块的不同元素在功能上的相关性。一般而言，您应尽力实现低耦合和高内聚：

- 低耦合是指模块应尽可能相互独立，这样一来，对一个模块所做的更改将对其他模块产生零影响或极小的影响。模块相互之间不应了解对方的内部运行原理。
- 高内聚是指多个模块的代码集合应当像一个系统一样运行。它们应具有明确定义的职责，并始终位于特定领域知识范围以内。假设有一个电子书应用示例。在同一个模块中融合图书相关代码和付款相关代码是不合适的，因为图书和付款是两个不同的功能领域。

> 如果两个模块相互严重依赖对方的信息，则可能表明这两个模块应当作为一个系统运行。相反，如果一个模块的两个部分并不经常相互交互，则这两个部分应当成为两个独立模块。

## 模块类型
### 数据模块
数据模块通常包含存储库、数据源和模型类。数据模块的三个主要职责包括：

1. **封装特定领域的所有数据和业务逻辑**：每个数据模块都应负责处理表示特定领域的数据。它可以处理许多类型的数据，只要这些数据相关即可。
2. **将存储库公开为外部 API**：数据模块的公共 API 应为存储库，因为它们负责向应用的其余部分公开数据。
3. **对外部隐藏所有实现细节和数据源**：只能由同一模块中的存储库访问数据源。它们对外部始终处于隐藏状态。您可以使用**Kotlin**的**private**或**internal**可见性关键字来实现此操作。

![示例数据模块及其内容](https://developer.android.google.cn/static/topic/modularization/images/2_data_modules.png?hl=zh-cn)
### 功能模块
功能是应用功能的独立部分，通常对应于一个屏幕或一系列密切相关的屏幕，例如注册或结账流程。如果您的应用具有底部导航栏，则每个目标位置都可能是一项功能。

![此应用的每个标签页均可定义为功能](https://developer.android.google.cn/static/topic/modularization/images/2_bottom_bar.png?hl=zh-cn)

功能与应用中的页面或目标位置相关联。因此，它们可能具有相关联的界面和**ViewModel**，用于处理其逻辑和状态。一项功能并不一定仅限于单一视图或导航目标位置。**功能模块依赖于数据模块**。

![功能模块及其内容示例](https://developer.android.google.cn/static/topic/modularization/images/2_feature_modules.png?hl=zh-cn)
### 应用模块
应用模块是应用的入口点。它们依赖于功能模块，并且通常提供根导航。由于支持 build 变体，因此单个应用模块可以编译为许多不同的二进制文件。

![*演示版*和*完整版*产品变种模块依赖关系图](https://developer.android.google.cn/static/topic/modularization/images/2_demo_full_dep_graph.png?hl=zh-cn)

如果您的应用以多种设备类型（例如汽车、穿戴式设备或电视）为目标平台，请分别为每种设备类型定义一个应用模块。这有助于分离特定于平台的依赖项。

![Wear 应用依赖关系图](https://developer.android.google.cn/static/topic/modularization/images/2_wear_dep_graph.png?hl=zh-cn)

### 通用模块
通用模块（也称为核心模块）包含其他模块经常使用的代码。它们可减少冗余，并且不代表应用架构中的任何特定层。下面列出了通用模块的一些示例：

- **界面模块**：如果您在应用中使用自定义界面元素或精心设计品牌元素，则应考虑将 widget 集合封装到一个模块中，以便重复使用所有功能。这有助于确保您的界面在不同功能之间保持一致。例如，如果您采用集中式主题，则在更换品牌名称时可以避免痛苦的重构过程。
- **分析模块**：跟踪通常取决于业务需求，而几乎不用考虑软件架构。分析跟踪器经常应用于许多不相关的组件。如果是这种情况，最好创建一个专用分析模块。
- **网络模块**：当许多模块需要网络连接时，您可以考虑创建一个专用于提供 http 客户端的模块。当客户端需要自定义配置，该模块尤为实用。
- **实用程序模块**：实用程序（也称为辅助程序）通常是在应用中重复使用的小段代码。实用程序的示例包括测试辅助程序、货币格式设置函数、电子邮件验证程序和自定义运算符。

### 测试模块
测试模块是仅用于测试用途的**Android**模块。 这些模块包含仅运行测试需要而应用运行时不需要的测试代码、测试资源和测试依赖项。测试模块可将测试专用代码与主应用分开，使模块代码更易于管理和维护。
以下示例展示了实现测试模块会带来很大好处的一些情况：

- **共享测试代码**：如果您的项目中有多个模块，并且某些测试代码适用于多个模块，那么您可以创建一个测试模块来共享代码。这有助于减少代码重复，使测试代码更易于维护。共享测试代码可以包括实用程序类或函数（例如自定义断言或匹配器）以及测试数据（例如模拟 JSON 响应）。
- **更简洁的 build 配置**：测试模块可让您拥有更简洁的 build 配置，因为它们可以拥有自己的**build.gradle**文件。这样您就不必在应用模块的**build.gradle**文件中堆满仅用于测试的配置。
- **集成测试**：测试模块可用于存储集成测试，这些测试用于测试应用的不同部分（包括界面、业务逻辑、网络请求和数据库）之间的互动查询。
- **大型应用**：测试模块对于具有复杂代码库和多个模块的大型应用特别有用。在这种情况下，测试模块可以帮助改进代码的组织和可维护性。

![测试模块可用于隔离原本相互依赖的模块](https://developer.android.google.cn/static/topic/modularization/images/2_test_modules.png?hl=zh-cn)

## 模块间通信
很少有模块是完全隔离的。模块之间通常相互依赖并相互通信。即使多个模块协同运行并频繁交换信息，也务必要保持低耦合。有时，与架构约束一样，两个模块之间进行直接通信是不可取的方式。此外，在使用循环依赖项等情况下，两个模块直接进行通信也是不可行的。

![使用循环依赖项时，在模块之间进行直接双向通信是不可行的。需要通过一个中介模块来协调两个其他独立模块之间的数据流](https://developer.android.google.cn/static/topic/modularization/images/2_mediator.png?hl=zh-cn)

为了克服此问题，您可以在两个模块之间使用第三个模块作为中介。中间模块可以监听来自这两个模块的消息，并根据需要转发消息。在我们的示例应用中，即使事件源自属于不同功能的单独页面，结账页面也需要知道要购买哪本图书。在这种情况下，拥有导航图的模块将充当中间模块（通常是应用模块）。在此示例中，我们使用导航组件将数据从主屏幕功能传递至结账功能。
```kotlin
navController.navigate("checkout/$bookId")
```
结账目标会接收图书 ID 作为参数，用于获取图书的相关信息。您可以使用已保存的状态句柄来检索目标功能的**ViewModel**内的导航参数。
```kotlin
class CheckoutViewModel(savedStateHandle: SavedStateHandle, …) : ViewModel() {

   val uiState: StateFlow<CheckoutUiState> =
      savedStateHandle.getStateFlow<String>("bookId", "").map { bookId ->
          // produce UI state calling bookRepository.getBook(bookId)
      }
      //
}
```
您不应将对象作为导航参数来传递，而是应使用简单的 ID，以便功能使用 ID 从数据层访问和加载所需资源。这样一来，您就可以保持低耦合，并且不会违反单一信息源原则。

在以下示例中，两个功能模块均依赖于同一个数据模块。这样可以尽可能减少中间模块需要转发的数据量，并在模块之间保持低耦合。模块应传递基元 ID 并从共享数据模块加载资源，而不是传递对象。

![两个功能模块依赖于一个共享数据模块](https://developer.android.google.cn/static/topic/modularization/images/2_shared_data.png?hl=zh-cn)

## 依赖项反转
依赖项反转是指整理代码，使抽象与具体实现分离开来。

- **抽象**：定义应用中的组件或模块如何彼此互动的协定。抽象模块定义系统的 API，并包含接口和模型。
- **具体实现**：依赖于抽象模块并实现抽象行为的模块。

依赖于抽象模块中定义的行为的模块应仅依赖于抽象本身，而不是特定的实现。

![高级别模块和实现模块依赖于抽象模块，而不是高级别模块直接依赖于低级别模块](https://developer.android.google.cn/static/topic/modularization/images/2_di_concept.png?hl=zh-cn)

### 示例
假设有一个需要数据库才能正常运行的功能模块。该功能模块与数据库的实现方式无关，无论是本地 Room 数据库还是远程 Firestore 实例，都是如此。只需要存储和读取应用数据。

为了实现这一点，功能模块依赖于抽象模块，而不是特定的数据库实现。此抽象定义了应用的数据库 API。换言之，它规定了如何与数据库互动的规则。这样，功能模块便可以使用任何数据库，而无需了解其底层实现细节。

具体实现模块提供抽象模块中定义的 API 的实际实现。为此，实现模块还依赖于抽象模块。
### 依赖项注入
现在，您可能想知道功能模块如何与实现模块连接。答案是依赖项注入。功能模块不会直接创建所需的数据库实例，而是指定所需的依赖项。然后，从外部提供（通常位于应用模块中）这些依赖项。
```kotlin
releaseImplementation(project(":database:impl:firestore"))

debugImplementation(project(":database:impl:room"))

androidTestImplementation(project(":database:impl:mock"))
```
> 您可以为不同的 build 类型定义不同的依赖项。例如，发布 build 可以使用 Firestore 实现，调试 build 可以依赖于本地 Room 数据库，而插桩测试可以采用模拟实现。

### 益处
分离 API 及其实现会带来以下益处：

- **可互换性**：通过明确分离 API 和实现模块，您可为同一 API 开发多个实现，并在不更改使用该 API 的代码的情况下在这些实现之间进行切换。如果您想要在不同的上下文中提供不同的功能或行为，这种方法特别有用。例如，用于测试的模拟实现与用于生产的真实实现。
- **分离**：这种分离意味着使用抽象的模块不依赖于任何特定的技术。如果您之后选择将数据库从 Room 更改为 Firestore，更改会更加容易，因为更改只会在执行该作业的特定模块（实现模块）中发生，而不会影响使用数据库 API 的其他模块。
- **可测试性**：将 API 与其实现分离有助于更方便地进行测试。您可以根据 API 协定编写测试用例。您还可以使用不同的实现来测试各种场景和极端情况，包括模拟实现。
- **提高了构建性能**：当您将某个 API 及其实现拆分为不同的模块时，实现模块中的更改不会强制构建系统根据 API 模块重新编译这些模块。这样可以缩短构建时间并提高工作效率，尤其是对于构建时间可能非常长的大型项目。

### 何时分离
在以下情况下，将 API 与其实现分离将大有益处：

- **多样功能**：如果您可以通过多种方式实现系统的某些部分，一个明晰的 API 有助于促成不同实现之间的可互换性。例如，您可能有一个使用 OpenGL 或 Vulkan 的渲染系统，或者有一个可与 Play 或内部结算 API 配合使用的结算系统。
- **多个应用**：如果您要针对不同平台开发多个具有共享功能的应用，可以定义通用 API 并针对每个平台开发特定的实现。
- **独立团队**：这种分离可让不同的开发者或团队同时处理代码库的不同部分。开发者应专注于了解 API 协定并正确使用它们，而无需担心其他模块的实现细节。
- **大型代码库**：如果代码库很大或很复杂，将 API 与实现分离可使代码更易于管理，让您可以将代码库细分为更精细、更易于理解且更易于维护的单元。

### 如何实现？
1. **创建抽象模块**：此模块应包含定义功能的行为的 API（接口和模型）。
2. **创建实现模块**：实现模块应依赖于 API 模块，并实现抽象的行为。
![实现模块依赖于抽象模块](https://developer.android.google.cn/static/topic/modularization/images/2_api_impl.png?hl=zh-cn)
3. **使高级别模块依赖于抽象模块**：使模块依赖于抽象模块，而不是直接依赖于特定的实现。高级别模块不需要知道实现细节，它们只需要协定 (API)。
![高级别模块依赖于抽象，而不是实现](https://developer.android.google.cn/static/topic/modularization/images/2_api_impl_feature.png?hl=zh-cn)
4. **提供实现模块**：最后，您需要为依赖项提供实际实现。特定实现取决于您的项目设置，不过应用模块通常是一个不错的选择。如需提供实现，请将其指定为您选择的 build 变体或测试源代码集的依赖项。
![应用模块提供实际实现](https://developer.android.google.cn/static/topic/modularization/images/2_api_impl_app.png?hl=zh-cn)

## 常见的最佳实践
正如开头所述，开发多模块应用并没有一种通用的正确方式。就像许多软件架构一样，也可以采用许多不同的方式来创建模块化应用。不过，以下一般性建议可帮助您提高代码的可读性、可维护性和可测试性。
### 保持配置一致
每个模块都会引入配置开销。如果模块数量达到特定阈值，保持一致的配置将成为一项挑战。例如，模块使用相同版本的依赖项非常重要。如果您需要更新大量模块来增加一个依赖项版本，这不仅是一项艰巨的任务，而且也很容易发生错误。如需解决此问题，您可以使用任一 Gradle 工具来集中管理配置：

- 版本目录是**Gradle**在同步期间生成的类型安全的依赖项列表。您可以在其中集中声明所有依赖项，并且可供项目中的所有模块使用。
- 使用惯例插件在模块之间共享 build 逻辑。

### 尽可能少公开信息
应尽量减少模块的公共接口，并且仅公开基本信息。不应向外部泄露任何实现细节。请尽可能缩小范围。使用**Kotlin**的**private**或**internal**可见性范围将模块声明设为私有模块。在模块中声明依赖项时，请优先使用**implementation**而不是**api**。后者会向模块的使用方公开传递依赖项。使用实现可以缩短构建时间，因为这样可以减少需要重新构建的模块数量。
### 首选 Kotlin 和 Java 模块
**Android Studio**支持以下三种基本类型的模块：

- **应用模块**是应用的入口点。它们可以包含源代码、资源、资产和**AndroidManifest.xml**。应用模块的输出是**Android App Bundle (AAB)**或**Android**应用软件包 (APK)。
- **库模块**具有与应用模块相同的内容。其他**Android**模块使用库模块作为依赖项。库模块的输出是**Android ARchive (AAR)**。库模块的输出在结构上与应用模块相同，但是会被编译为**Android ARchive (AAR)**文件，这些文件随后可以作为依赖项供其他模块使用。借助库模块，您可以在多个应用模块中封装和重复使用相同的逻辑和资源。
- **Kotlin 和 Java 库**不包含任何**Android**资源、资产或清单文件。

**Android**模块会产生开销，因此您应当优先尽可能多地使用**Kotlin**或**Java**库。


